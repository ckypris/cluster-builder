---
- hosts: all
  gather_facts: false

  vars:
    fusion_vm_folder: ../virtuals
    ova_template_path: "../{{ ova_template }}"
    gen_script_folder: ../tmp/{{ cluster_pkg_folder }}
    fusion_net: 'vmnet2'
  roles:
    - role: common

  tasks:    
  - name: Set vmware dhcpd configuration location for linux
    set_fact:
      vmware_dhcpd_base_path: "/etc/vmware/{{ fusion_net }}/dhcp"
      vmware_dhcpd_filename: "dhcpd.conf"
    run_once: true
    when: platform == "linux"

  - name: Set vmware dhcpd configuration location for macOS
    set_fact:
      vmware_dhcpd_base_path: "/Library/Preferences/VMware\ Fusion/{{ fusion_net }}"
      vmware_dhcpd_filename: "dhcpd.conf"
    run_once: true
    when: platform == "darwin"

  - name: Set vmware dhcpd configuration location for Windows
    set_fact:
      vmware_dhcpd_base_path: "/mnt/c/ProgramData/VMware"
      vmware_dhcpd_filename: "vmnetdhcp.conf"
    run_once: true
    when: platform == "windows"

  - debug: msg="{{ vmware_dhcpd_base_path }}"

  - name: Set server_static_ip_wait_seconds if undefined
    set_fact:
      server_static_ip_wait_seconds: 30
    run_once: true
    when: server_static_ip_wait_seconds is undefined

  - name: Ensure the target fusion_vm_folder exists
    local_action:
      module: file
      path: "{{ fusion_vm_folder }}"
      state: directory

  - name: Ensure the target folder for generated scripts exists
    local_action:
      module: file
      path: "{{ gen_script_folder }}"
      state: directory

  - name: Calculate VM folder names for Windows
    set_fact:
      vm_folder_name: "{{ inventory_hostname }}"
    when: platform == "windows"

  - name: Calculate VM folder names for macOS
    set_fact:
      vm_folder_name: "{{ vm_folder_name }}.vmwarevm"
    when: platform == "darwin"

  - name: Calculate VM folder names for Linux
    set_fact:
      vm_folder_name: "{{ vm_folder_name }}"
    when: platform == "linux"

  - name: Stop the existing VMs (If they aren't running the errors will be ignored) on macOS and Linux.
    local_action:
      module: shell
      _raw_params: vmrun stop {{ fusion_vm_folder }}/{{ vm_folder_name }}/{{ inventory_hostname }}.vmx
    ignore_errors: true
    when: platform == "linux" or platform == "darwin"

  - name: Calculate Windows path using wslpath.
    local_action:
      module: shell
      _raw_params: "wslpath -w {{ fusion_vm_folder }}/{{ vm_folder_name }}/{{ inventory_hostname }}.vmx"
    register: windows_vm_start_path
    ignore_errors: true
    when: platform == "windows"

  - name: Stop the existing VMs (If they aren't running the errors will be ignored) on Windows.
    local_action:
      module: shell
      _raw_params: "vmrun.exe stop {{ fusion_vm_folder }}/{{ vm_folder_name }}/{{ inventory_hostname }}.vmx"
    ignore_errors: true
    when: platform == "windows"

  - name: Use ovftool to deploy cluster-node ova to Fusion VMX on macOS/Linux.
    local_action:
      module: shell
      _raw_params: ovftool -tt=vmx -o --network={{ fusion_net }} --powerOffTarget --name={{ inventory_hostname }} {{ ova_template_path }} {{ fusion_vm_folder }}/
    when: platform == "linux" or platform == "darwin"

  - name: Remove existing VMs if they exist
    local_action:
      module: shell
      _raw_params: "rm -rf {{ fusion_vm_folder }}/{{ vm_folder_name }}/{{ inventory_hostname }}.vmx"
    when: platform == "windows" and overwrite_existing_vms
    ignore_errors: true

  - name: Use ovftool to deploy cluster-node ova to Fusion VMX on Windows.
    local_action:
      module: shell
      _raw_params: "ovftool.exe -tt=vmx --overwrite --network={{ fusion_net }} --powerOffTarget --name={{ inventory_hostname }} {{ ova_template_path }} {{ fusion_vm_folder }}"
    when: platform == "windows" 

  - name: Assign the VM CPU Count
    local_action:
      module: lineinfile
      path: "{{ fusion_vm_folder }}/{{ vm_folder_name }}/{{ inventory_hostname }}.vmx"
      state: present
      regexp: '^numvcpus =\s'
      line: 'numvcpus = "{{ numvcpus }}"'
    when: numvcpus is defined

  - name: Assign the VM Memory
    local_action:
      module: lineinfile
      path: "{{ fusion_vm_folder }}/{{ vm_folder_name }}/{{ inventory_hostname }}.vmx"
      state: present
      regexp: '^memsize =\s'
      line: 'memsize = "{{ memsize }}"'
    when: memsize is defined

  - name: Start the VMs to get the generated MAC addresses on macOS/Linux
    local_action:
      module: shell
      _raw_params: vmrun start {{ fusion_vm_folder }}/{{ vm_folder_name }}/{{ inventory_hostname }}.vmx nogui
    become: false
    when: platform == "linux" or platform == "darwin"

  - name: Start the VMs to get the generated MAC addresses on Windows
    local_action:
      module: shell
      _raw_params: "vmrun.exe start {{ fusion_vm_folder }}/{{ vm_folder_name }}/{{ inventory_hostname }}.vmx nogui"
    become: false
    when: platform == "windows"

  - name: Waiting for VMs to generate MAC addresses
    pause:
      seconds: 60
    
  - name: Scan the VMX files for the Control/Data mac addresses
    local_action:
      module: shell
      _raw_params: cat {{ fusion_vm_folder }}/{{ vm_folder_name }}/{{ inventory_hostname }}.vmx | grep "ethernet0.generatedAddress = " | sed -e 's/ethernet0.generatedAddress = //g' -e 's/"//g'
    register: vm_mac
  
  - debug: msg="{{ vm_mac.stdout }}"

  - fail: msg="No MAC Found! Unable to get the MAC address from the VMX!"
    when: vm_mac is not defined

  - name: Generate the DHCPD Control configuration entries
    local_action:
      module: template
      src: templates/dhcpd_entry.j2
      dest: "{{ gen_script_folder }}/{{ inventory_hostname }}_dhcpd.conf"
  
  - name: Stop the VMs on macOS/Linux
    local_action:
      module: shell
      _raw_params: vmrun stop {{ fusion_vm_folder}}/{{ vm_folder_name }}/{{ inventory_hostname }}.vmx nogui
    when: platform == "linux" or platform == "darwin"

  - name: Stop the VMs on Windows
    local_action:
      module: shell
      _raw_params: "vmrun.exe stop {{ fusion_vm_folder}}/{{ vm_folder_name }}/{{ inventory_hostname }}.vmx nogui"
    when: platform == "windows"

  - name: Assign the Fusion Control Network Connection Type
    local_action:
      module: lineinfile
      path: "{{ fusion_vm_folder }}/{{ vm_folder_name }}/{{ inventory_hostname }}.vmx"
      state: present
      regexp: '^ethernet0.connectionType =\s'
      line: 'ethernet0.connectionType = "{{ fusion_net_type }}"'

  - name: Assign the Fusion Control Network to Interface One
    local_action:
      module: lineinfile
      path: "{{ fusion_vm_folder }}/{{ vm_folder_name }}/{{ inventory_hostname }}.vmx"
      state: present
      regexp: '^ethernet0.vnet =\s'
      line: 'ethernet0.vnet = "{{ fusion_net }}"'

  - name: Remove the DHCPD Control fragment file
    local_action:
      module: shell
      _raw_params: rm {{ gen_script_folder }}/dhcpd_frag.conf
    ignore_errors: true
    run_once: true

  - name: Concatenate the Control entry header
    local_action:
      module: shell
      _raw_params: echo '### {{ cluster_type }}:{{ cluster_name }}:start' >> {{ gen_script_folder }}/dhcpd_frag.conf
    run_once: true

  - name: Concatenate the new Control/Data entries
    local_action:
      module: shell
      _raw_params: cat {{ gen_script_folder }}/{{ inventory_hostname }}_dhcpd.conf >> {{ gen_script_folder }}/dhcpd_frag.conf

  - name: Concatenate the DHCPD entry footer
    local_action:
      module: shell
      _raw_params: echo '### {{ cluster_type }}:{{ cluster_name }}:end' >> {{ gen_script_folder }}/dhcpd_frag.conf
    run_once: true

  - name: Stop the VM Network on macOS
    local_action:
      module: shell
      _raw_params: 'vmnet-cli --stop'
    delegate_to: 127.0.0.1
    become: true
    run_once: true
    when: platform == "darwin"

  - name: Stop the VM Network on Windows
    local_action:
      module: shell
      _raw_params: '/mnt/c/Windows/System32/net.exe stop vmnetdhcp'
    delegate_to: 127.0.0.1
    become: true
    run_once: true
    when: platform == "windows"

  - name: Stop the VM Network on Linux
    local_action:
      module: shell
      _raw_params: 'systemctl stop vmnetdhcp'
    delegate_to: 127.0.0.1
    become: true
    run_once: true
    when: platform =="linux"

  - name: Remove any Control block for the current cluster
    local_action:
      module: shell
      _raw_params: sed '/### {{ cluster_type }}:{{ cluster_name }}:start/,/### {{ cluster_type }}:{{ cluster_name }}:end/d' '{{ vmware_dhcpd_base_path }}/{{ vmware_dhcpd_filename }}' > '{{ vmware_dhcpd_base_path }}/dhcpd-temp.conf'
    delegate_to: 127.0.0.1
    become: true
    run_once: true

  - name: Load Control block into memory
    local_action:
      module: shell
      _raw_params: cat '{{ gen_script_folder }}/dhcpd_frag.conf'
    delegate_to: 127.0.0.1
    register: vmware_dhcp_control_block
    become: true
    run_once: true
    when: platform == "windows"

  - name: View control block
    debug: msg="{{ vmware_dhcp_control_block.stdout_lines }}"

  - name: Update Windows vmnet file
    local_action:
      module: shell
      _raw_params: sed -n -i -e '/host VMnet2/r {{ gen_script_folder }}/dhcpd_frag.conf' -e 1x -e '2,${x;p}' -e '${x;p}' {{ vmware_dhcpd_base_path }}/dhcpd-temp.conf
    delegate_to: 127.0.0.1
    register: vmware_dhcp_control_block
    become: true
    run_once: true
    when: platform == "windows"


#  - name: Update Windows vmnet file
#    local_action: 
#      module: lineinfile
#      dest: '{{ vmware_dhcpd_base_path }}/dhcpd-temp.conf'
#      insertbefore: "host VMnet2"
#      line: "{{ item.line }}"
#    with_items:  
#      - "{{ vmware_dhcp_control_block.stdout_lines }}"
#    run_once: true
#    when: platform == "windows"

  - name: Add current DHCP Control block for cluster
    local_action:
      module: shell
      _raw_params: cat {{ gen_script_folder }}/dhcpd_frag.conf >> '{{ vmware_dhcpd_base_path }}/dhcpd-temp.conf'
    delegate_to: 127.0.0.1
    become: true
    run_once: true
    when: platform != "windows"

  - name: Backup current Control DHCP
    local_action:
      module: shell
      _raw_params: cp '{{ vmware_dhcpd_base_path }}/{{ vmware_dhcpd_filename }}' '{{ vmware_dhcpd_base_path }}/{{ vmware_dhcpd_filename }}.backup'
    delegate_to: 127.0.0.1
    become: true
    run_once: true

  - name: Replace current Control DHCP
    local_action:
      module: shell
      _raw_params: mv '{{ vmware_dhcpd_base_path }}/dhcpd-temp.conf' '{{ vmware_dhcpd_base_path }}/{{ vmware_dhcpd_filename }}'
    delegate_to: 127.0.0.1
    become: true
    run_once: true

  - name: Start the VM Network on macOS
    local_action:
      module: shell
      _raw_params: 'vmnet-cli --start'
    delegate_to: 127.0.0.1
    become: true
    run_once: true
    when: platform == "darwin"

  - name: Start the VM Network on Windows
    local_action:
      module: shell
      _raw_params: '/mnt/c/Windows/System32/net.exe start vmnetdhcp'
    delegate_to: 127.0.0.1
    become: true
    run_once: true
    when: platform == "windows"

  - name: Start the VM Network on Linux
    local_action:
      module: shell
      _raw_params: 'vmnet-cli --start'
    delegate_to: 127.0.0.1
    become: true
    run_once: true
    when: platform == "linux"
    
  - name: Remove the DHCPD Control/Data configuration file fragments
    local_action:
      module: file
      path: "{{ gen_script_folder }}/{{ inventory_hostname }}_dhcpd.conf"
      state: absent
    delegate_to: 127.0.0.1
    
  - name: Start the VMs on macOS/Linux
    local_action:
      module: shell
      _raw_params: vmrun start {{ fusion_vm_folder}}/{{ vm_folder_name }}/{{ inventory_hostname }}.vmx nogui
    when: platform == "darwin" or platform == "linux"

  - name: Start the VMs on Windows
    local_action:
      module: shell
      _raw_params: "vmrun.exe start {{ fusion_vm_folder}}/{{ vm_folder_name }}/{{ inventory_hostname }}.vmx nogui"
    when: platform == "windows"

  - name: waiting {{ server_static_ip_wait_seconds }} seconds for servers to start up and fetch their permanent ip addresses
    local_action: wait_for host={{ inventory_hostname }} port=22 state=started delay={{ server_static_ip_wait_seconds }} timeout=600
    become: false
