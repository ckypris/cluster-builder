# This playbook deploys a CoreOS Cluster via PXE/iPXE and Matchbox services in Fusion
---
- hosts: all
  gather_facts: false
  tasks:
  - name: set coreos_linux_version
    set_fact:
      coreos_linux_version: "1745.7.0"
    run_once: true
    when: coreos_linux_version is undefined

  - name: set coreos_linux_channel
    set_fact:
      coreos_linux_channel: "stable"
    run_once: true
    when: coreos_linux_channel is undefined

- hosts: coreos_provisioner
  gather_facts: true
  become_user: admin
  remote_user: admin
  become: true
  vars:
    gen_script_folder: ../tmp/{{ cluster_pkg_folder }}
    deployment_scale: "{{ deployment_scale | default(50) }}"

  roles:
    - role: common
    - role: coreos-update-matchbox

- hosts: vmware_vms
  gather_facts: false

  vars:
    fusion_vm_folder: ../virtuals
    ova_template_path: "../{{ ova_template }}"
    gen_script_folder: ../tmp/{{ cluster_pkg_folder }}

  tasks:    
  - name: set vmware dhcpd configuration location for linux
    set_fact:
      vmware_dhcpd_base_path: "/etc/vmware/{{ fusion_net }}/dhcp"
      vmware_dhcpd_filename: "dhcpd.conf"
    run_once: true
    when: platform == "linux"

  - name: set vmware dhcpd configuration location for macOS
    set_fact:
      vmware_dhcpd_base_path: "/Library/Preferences/VMware\ Fusion/{{ fusion_net }}"
      vmware_dhcpd_filename: "dhcpd.conf"
    run_once: true
    when: platform == "darwin"

  - name: set vmware dhcpd configuration location for Windows
    set_fact:
      vmware_dhcpd_base_path: "/mnt/c/ProgramData/VMware"
      vmware_dhcpd_filename: "vmnetdhcp.conf"
    run_once: true
    when: platform == "windows"

  - debug: msg="{{ vmware_dhcpd_base_path }}"

  - name: ensure the target fusion_vm_folder exists
    local_action:
      module: file
      path: "{{ fusion_vm_folder }}"
      state: directory

  - name: stop the existing VMs (If they aren't running the errors will be ignored) on macOS and Linux.
    local_action:
      module: shell
      _raw_params: vmrun stop {{ fusion_vm_folder }}/{{ vm_folder_name }}/{{ inventory_hostname }}.vmx
    ignore_errors: true
    when: platform == "linux" or platform == "darwin"

  - name: stop the existing VMs (If they aren't running the errors will be ignored) on Windows.
    local_action:
      module: shell
      _raw_params: "vmrun.exe stop {{ fusion_vm_folder }}/{{ vm_folder_name }}/{{ inventory_hostname }}.vmx"
    ignore_errors: true
    when: platform == "windows"

  - name: use ovftool to deploy cluster-node ova to Fusion VMX on macOS/Linux.
    local_action:
      module: shell
      _raw_params: ovftool -tt=vmx -o --network={{ fusion_net }} --powerOffTarget --name={{ inventory_hostname }} {{ ova_template_path }} {{ fusion_vm_folder }}/
    when: platform == "linux" or platform == "darwin"

  - name: remove existing VMs if they exist
    local_action:
      module: shell
      _raw_params: "rm -rf {{ fusion_vm_folder }}/{{ vm_folder_name }}/{{ inventory_hostname }}.vmx"
    when: platform == "windows" and overwrite_existing_vms
    ignore_errors: true

  - name: use ovftool to deploy cluster-node ova to Fusion VMX on Windows.
    local_action:
      module: shell
      _raw_params: "ovftool.exe -tt=vmx --overwrite --network={{ fusion_net }} --powerOffTarget --name={{ inventory_hostname }} {{ ova_template_path }} {{ fusion_vm_folder }}"
    when: platform == "windows" 

  - name: calculate VM folder names for Windows
    set_fact:
      vm_folder_name: "{{ inventory_hostname }}"
    when: platform == "windows"

  - name: calculate VM folder names for macOS
    set_fact:
      vm_folder_name: "{{ vm_folder_name }}.vmwarevm"
    when: platform == "darwin"

  - name: calculate VM folder names for Linux
    set_fact:
      vm_folder_name: "{{ vm_folder_name }}"
    when: platform == "linux"

  - name: assign the VM CPU Count
    local_action:
      module: lineinfile
      path: "{{ fusion_vm_folder }}/{{ vm_folder_name }}/{{ inventory_hostname }}.vmx"
      state: present
      regexp: '^numvcpus =\s'
      line: 'numvcpus = "{{ numvcpus }}"'
    when: numvcpus is defined

  - name: assign the VM memory
    local_action:
      module: lineinfile
      path: "{{ fusion_vm_folder }}/{{ vm_folder_name }}/{{ inventory_hostname }}.vmx"
      state: present
      regexp: '^memsize =\s'
      line: 'memsize = "{{ memsize }}"'
    when: memsize is defined

  - name: assign the Fusion network to primary interface 
    local_action:
      module: lineinfile
      path: "{{ fusion_vm_folder }}/{{ vm_folder_name }}/{{ inventory_hostname }}.vmx"
      state: present
      regexp: '^ethernet0.vnet =\s'
      line: 'ethernet0.vnet = "{{ fusion_net }}"'

  - name: Assign the Fusion network type
    local_action:
      module: lineinfile
      path: "{{ fusion_vm_folder }}/{{ vm_folder_name }}/{{ inventory_hostname }}.vmx"
      state: present
      regexp: '^ethernet0.connectionType\s'
      line: 'ethernet0.connectionType = "custom"'

  - name: start the VMs to get the generated MAC addresses on macOS/Linux
    local_action:
      module: shell
      _raw_params: vmrun start {{ fusion_vm_folder }}/{{ vm_folder_name }}/{{ inventory_hostname }}.vmx nogui
    become: false
    when: platform == "linux" or platform == "darwin"

  - name: start the VMs to get the generated MAC addresses on Windows
    local_action:
      module: shell
      _raw_params: "vmrun.exe start {{ fusion_vm_folder }}/{{ vm_folder_name }}/{{ inventory_hostname }}.vmx nogui"
    become: false
    when: platform == "windows"

  - name: waiting for VMs to generate MAC addresses
    pause:
      seconds: 30
    
  - name: scan the VMX files for the mac addresses
    local_action:
      module: shell
      _raw_params: cat {{ fusion_vm_folder }}/{{ vm_folder_name }}/{{ inventory_hostname }}.vmx | grep "ethernet0.generatedAddress = " | sed -e 's/ethernet0.generatedAddress = //g' -e 's/"//g'
    register: vm_mac_addr
  
  - debug: msg="{{ vm_mac_addr.stdout }}"

  - fail: msg="No MAC Found! Unable to get the MAC address from the VMX!"
    when: vm_mac_addr is not defined    

  - name: set MAC address fact
    set_fact:
      vm_mac_addr: "{{ vm_mac_addr.stdout }}"

  - name: stop the VMs 
    local_action:
      module: shell
      _raw_params: vmrun stop {{ fusion_vm_folder }}/{{ vm_folder_name }}/{{ inventory_hostname }}.vmx nogui
    become: false


- hosts: coreos_controllers,coreos_workers
  remote_user: admin
  become: true
  any_errors_fatal: true
  gather_facts: false
  vars:

    tectonic_controller_domain: "{{ tectonic_controller_dn }}"

    tectonic_matchbox_http_url: "http://{{ provisioner_server_dn }}:8080"
    tectonic_matchbox_rpc_endpoint: "{{ provisioner_server_dn }}:8081"

    tectonic_ingress_domain: "{{ tectonic_ingress_dn }}"

    tectonic_service_cidr: "10.3.0.0/16"

  tasks:

  - name: load tectonic_matchbox_ca
    local_action:
      module: shell
      _raw_params: "cat ../clusters/{{ cluster_pkg_folder }}/matchbox-certs/ca.crt"
    register: tectonic_matchbox_ca_load
    become: false
    run_once: true

  - debug: msg="{{ tectonic_matchbox_ca_load.stdout }}" 
    run_once: true

  - name: set vanilla k8s default to false (Full Tectonic Install)
    set_fact:
      tectonic_vanilla_k8s: false
    run_once: true
    when: tectonic_vanilla_k8s is undefined

  - name: set tectonic_matchbox_ca
    set_fact:
      tectonic_matchbox_ca: "{{ tectonic_matchbox_ca_load.stdout }}"
    run_once: true

  - name: load tectonic_matchbox_client_cert
    local_action:
      module: shell
      _raw_params: "cat ../clusters/{{ cluster_pkg_folder }}/matchbox-certs/client.crt"
    register: tectonic_matchbox_client_cert_load
    become: false
    run_once: true

  - debug: msg="{{ tectonic_matchbox_client_cert_load.stdout }}" 
    run_once: true

  - name: set tectonic_matchbox_client_cert
    set_fact:
      tectonic_matchbox_client_cert: "{{ tectonic_matchbox_client_cert_load.stdout }}"
    run_once: true

  - name: load tectonic_matchbox_client_key
    local_action:
      module: shell
      _raw_params: "cat ../clusters/{{ cluster_pkg_folder }}/matchbox-certs/client.key"
    register: tectonic_matchbox_client_key_load
    become: false
    run_once: true

  - debug: msg="{{ tectonic_matchbox_client_key_load.stdout }}" 
    run_once: true

  - name: set tectonic_matchbox_client_key
    set_fact:
      tectonic_matchbox_client_key: "{{ tectonic_matchbox_client_key_load.stdout }}"
    run_once: true

  - name: load ssh key
    local_action:
      module: shell
      _raw_params: "cat ../node-packer/keys/authorized_keys"
    register: tectonic_ssh_key_load
    become: false
    run_once: true

  - debug: msg="{{  tectonic_ssh_key_load.stdout }}" 
    run_once: true

  - name: set tectonic_ssh_authorized_key
    set_fact:
      tectonic_ssh_authorized_key: "{{  tectonic_ssh_key_load.stdout }}"
    run_once: true

  - name: generate the terraform.vars file
    local_action:
      module: template
      src: templates/coreos-terraform.j2
      dest: ../clusters/{{ cluster_pkg_folder }}/terraform.tfvars
      mode: 0766
    become: false
    run_once: true

  - name: generate the controllers.csv file
    local_action:
      module: template
      src: templates/coreos-masters-csv.j2
      dest: ../clusters/{{ cluster_pkg_folder }}/manual-masters.csv
      mode: 0766
    become: false
    run_once: true

  - name: generate the workers.csv file
    local_action:
      module: template
      src: templates/coreos-workers-csv.j2
      dest: ../clusters/{{ cluster_pkg_folder }}/manual-workers.csv
      mode: 0766
    become: false
    run_once: true

- hosts: coreos_provisioner,coreos_workers,coreos_controllers
  remote_user: admin
  become: true
  any_errors_fatal: true
  gather_facts: false
  vars:
    tmp_folder: ../tmp/
    gen_script_folder: ../tmp/{{ cluster_pkg_folder }}

  tasks:
    
  - name: process the DHCP template file
    local_action:
      module: template
      src: templates/coreos-fusion-dhcpd-static-block.j2
      dest: ../tmp/coreos-dhcpd-block.txt
    become: false
    when: inventory_hostname in groups['coreos_provisioner']
    run_once: true

  - name: load dhcpd block
    local_action:
      module: shell
      _raw_params: "cat {{ tmp_folder }}/coreos-dhcpd-block.txt"
    register: coreos_dhcpd_static_block
    become: false
    run_once: true

  - debug: msg="{{ coreos_dhcpd_static_block.stdout_lines }}" 
    run_once: true

  - name: stop the VM network on macOS
    local_action:
      module: shell
      _raw_params: 'vmnet-cli --stop'
    delegate_to: 127.0.0.1
    become: true
    run_once: true
    when: platform == "darwin"

  - name: stop the VM network on Windows
    local_action:
      module: shell
      _raw_params: '/mnt/c/Windows/System32/net.exe stop vmnetdhcp'
    delegate_to: 127.0.0.1
    ignore_errors: true
    become: true
    run_once: true
    when: platform == "windows"

  - name: stop the VM network on Linux
    local_action:
      module: shell
      _raw_params: 'systemctl stop vmnetdhcp'
    delegate_to: 127.0.0.1
    become: true
    run_once: true
    when: platform =="linux"

  - name: remove any DHCPD block for the current cluster
    local_action:
      module: shell
      _raw_params: sed '/### {{ cluster_type }}:{{ cluster_name }}:start/,/### {{ cluster_type }}:{{ cluster_name }}:end/d' '{{ vmware_dhcpd_base_path }}/{{ vmware_dhcpd_filename }}' > '{{ vmware_dhcpd_base_path }}/dhcpd-temp.conf'
    delegate_to: 127.0.0.1
    become: true
    run_once: true

  - name: load DHCPD block into memory
    local_action:
      module: shell
      _raw_params: cat '{{ gen_script_folder }}/dhcpd_frag.conf'
    delegate_to: 127.0.0.1
    register: vmware_dhcp_control_block
    become: true
    run_once: true
    when: platform == "windows"

  - name: view DHCPD block
    debug: msg="{{ vmware_dhcp_control_block.stdout_lines }}"

  - name: add current DHCP block for cluster
    local_action:
      module: shell
      _raw_params: cat {{ gen_script_folder }}/dhcpd_frag.conf >> '{{ vmware_dhcpd_base_path }}/dhcpd-temp.conf'
    delegate_to: 127.0.0.1
    become: true
    run_once: true
#    when: platform != "windows"

  - name: backup current DHCP settings file
    local_action:
      module: shell
      _raw_params: cp '{{ vmware_dhcpd_base_path }}/{{ vmware_dhcpd_filename }}' '{{ vmware_dhcpd_base_path }}/{{ vmware_dhcpd_filename }}.backup'
    delegate_to: 127.0.0.1
    become: true
    run_once: true

  - name: replace current DHCP settings file
    local_action:
      module: shell
      _raw_params: mv '{{ vmware_dhcpd_base_path }}/dhcpd-temp.conf' '{{ vmware_dhcpd_base_path }}/{{ vmware_dhcpd_filename }}'
    delegate_to: 127.0.0.1
    become: true
    run_once: true

  - name: start the VM network on macOS
    local_action:
      module: shell
      _raw_params: 'vmnet-cli --start'
    delegate_to: 127.0.0.1
    become: true
    run_once: true
    when: platform == "darwin"

  - name: start the VM network on Windows
    local_action:
      module: shell
      _raw_params: '/mnt/c/Windows/System32/net.exe start vmnetdhcp'
    delegate_to: 127.0.0.1
    become: true
    run_once: true
    when: platform == "windows"

  - name: start the VM network on Linux
    local_action:
      module: shell
      _raw_params: 'vmnet-cli --start'
    delegate_to: 127.0.0.1
    become: true
    run_once: true
    when: platform == "linux"

  - name: clean up tmp dhcpd block
    local_action:
      module: shell
      _raw_params: "rm {{ tmp_folder }}/coreos-dhcpd-block.txt"
    become: false
    run_once: true
        