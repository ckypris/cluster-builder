#
# Right now this just installs portainer on the first manager
# TODO: breakout the scripts for secure-api and container so they can 
# be run indendently - in case of m1 node failure, m2 or m3 can be
# provisioned for remote api and portainer access on demand

---
- name: install docker-compose python module
  pip: name={{ item }} state=latest
  with_items:
    - docker-compose
  when: "inventory_hostname == groups['docker_swarm_manager'][0]"

- name: pull portainer image
  shell: docker pull portainer/portainer:develop
  when: "inventory_hostname == groups['docker_swarm_manager'][0]"

- name: stop any existing Portainer container (if running)
  shell: docker stop portainer
  ignore_errors: true
  when: "inventory_hostname == groups['docker_swarm_manager'][0]"

- name: remove any existing Portainer container (if exists)
  shell: docker rm portainer
  ignore_errors: true
  when: "inventory_hostname == groups['docker_swarm_manager'][0]"

- name: start portainer the old fashioned way
  shell: 
    cmd: | 
      docker service create --constraint "node.role == manager" -p 9000:9000 \
      --name portainer \
      --network bridge \
      --mount source=portainer-data,destination=/data \
      --mount type=bind,source=/etc/certs/docker,destination=/certs \
      --mount type=bind,source=/var/run/docker.sock,destination=/var/run/docker.sock \
      portainer/portainer:develop -H unix:///var/run/docker.sock --tlsverify
  ignore_errors: true
  register: portainer_start
  when: "inventory_hostname == groups['docker_swarm_manager'][0]"

- debug: msg="{{ portainer_start.stdout }}"
  when: "inventory_hostname == groups['docker_swarm_manager'][0]"

